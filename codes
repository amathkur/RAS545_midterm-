#!/usr/bin/env python3
# agent_xo_sleep.py
import argparse, time, math, collections
import numpy as np
import cv2

# ---------- Optional ROS ----------
USE_ROS = False
try:
    import rclpy
    from rclpy.node import Node
    from std_msgs.msg import String
    USE_ROS = True
except Exception:
    USE_ROS = False

LETTERS = "ABCDEFGHI"

# ---------- Camera backends ----------
def open_usb_cam(device=0, res="640x480", fps=30):
    w,h = [int(x) for x in res.lower().split('x')]
    cap = cv2.VideoCapture(int(device), cv2.CAP_V4L2)
    cap.set(cv2.CAP_PROP_FRAME_WIDTH,  w)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, h)
    cap.set(cv2.CAP_PROP_FPS,          fps)
    if not cap.isOpened():
        raise RuntimeError(f"‚ùå USB camera {device} failed to open")
    def read():
        ok, frame = cap.read()
        return frame if ok else None
    def close():
        try: cap.release()
        except Exception: pass
    return read, close, f"USB({device})"

def open_d435(res="640x480", fps=30):
    import pyrealsense2 as rs
    w,h = [int(x) for x in res.lower().split('x')]
    pipe = rs.pipeline()
    cfg  = rs.config()
    cfg.enable_stream(rs.stream.color, w, h, rs.format.bgr8, fps)
    pipe.start(cfg)
    def read():
        frames = pipe.wait_for_frames()
        color = frames.get_color_frame()
        if not color: return None
        return np.asanyarray(color.get_data())
    def close():
        try: pipe.stop()
        except Exception: pass
    return read, close, "D435"

# ---------- Grid helpers ----------
def letter_cell_rect(letter, W, H):
    idx = LETTERS.index(letter)
    row, col = divmod(idx, 3)
    x0 = int(col * W/3); x1 = int((col+1) * W/3)
    y0 = int(row * H/3); y1 = int((row+1) * H/3)
    return (x0,y0,x1,y1)

def pixel_to_letter(x, y, W, H):
    col = min(2, max(0, int(3*x/W)))
    row = min(2, max(0, int(3*y/H)))
    return LETTERS[row*3+col]

def draw_grid_and_labels(frame, occupied):
    H, W = frame.shape[:2]
    x1, x2 = W//3, (2*W)//3
    y1, y2 = H//3, (2*H)//3
    t = max(1, min(H, W)//300)
    cv2.line(frame, (x1, 0),   (x1, H-1), (0,255,0), t)
    cv2.line(frame, (x2, 0),   (x2, H-1), (0,255,0), t)
    cv2.line(frame, (0,  y1),  (W-1, y1), (0,255,0), t)
    cv2.line(frame, (0,  y2),  (W-1, y2), (0,255,0), t)
    # A..I labels and occupied overlay
    for i, L in enumerate(LETTERS):
        r, c = divmod(i, 3)
        x = int((c+0.05)*W/3); y = int((r+0.12)*H/3)
        col = (0,255,255)
        if L in occupied:
            # red corner box
            x0,y0,x1,y1 = letter_cell_rect(L, W, H)
            cv2.rectangle(frame, (x0+2,y0+2), (x1-2,y1-2), (0,0,255), 2)
            cv2.putText(frame, L, (x,y), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,0,255), 2)
            cv2.putText(frame, "TAKEN", (x, y+18), cv2.FONT_HERSHEY_PLAIN, 1.2, (0,0,255), 2)
        else:
            cv2.putText(frame, L, (x,y), cv2.FONT_HERSHEY_SIMPLEX, 0.7, col, 2)

# ---------- Geometry ----------
def angle_of(line):
    x1,y1,x2,y2 = line
    ang = math.degrees(math.atan2(y2-y1, x2-x1))
    return (ang+180)%180  # 0..180

def line_len(line):
    x1,y1,x2,y2 = line
    return math.hypot(x2-x1, y2-y1)

def intersection(p1, p2, p3, p4):
    x1,y1 = p1; x2,y2 = p2; x3,y3 = p3; x4,y4 = p4
    den = (x1-x2)*(y3-y4)-(y1-y2)*(x3-x4)
    if abs(den) < 1e-6: return None
    xi = ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/den
    yi = ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/den
    return (xi, yi)

# ---------- Detectors ----------
def detect_O_in_roi(gray_roi, c1, c2, rmin, rmax):
    edges = cv2.Canny(gray_roi, c1, c2)
    # try Hough straight on edges
    circ = cv2.HoughCircles(edges, cv2.HOUGH_GRADIENT, 1.2, 18,
                            param1=100, param2=15, minRadius=rmin, maxRadius=rmax)
    if circ is not None and len(circ[0])>0:
        c = np.uint16(np.around(circ[0][0]))
        return True, (int(c[0]), int(c[1]), int(c[2])), 1.0
    # gentle close to connect broken O
    kernel = np.ones((3,3), np.uint8)
    closed = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel, iterations=2)
    circ = cv2.HoughCircles(closed, cv2.HOUGH_GRADIENT, 1.2, 18,
                            param1=100, param2=12, minRadius=rmin, maxRadius=rmax)
    if circ is not None and len(circ[0])>0:
        c = np.uint16(np.around(circ[0][0]))
        return True, (int(c[0]), int(c[1]), int(c[2])), 0.85
    # contour circularity fallback
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    best = None; best_score = 0.0
    for cnt in contours:
        area = cv2.contourArea(cnt)
        if area < 80: continue
        per = max(1e-6, cv2.arcLength(cnt, True))
        circularity = 4*np.pi*area/(per*per)  # 1.0 for perfect circle
        (x,y), r = cv2.minEnclosingCircle(cnt)
        r = int(r)
        if r < rmin or r > rmax: continue
        score = float(circularity)
        if score > best_score:
            best_score = score; best = (int(x), int(y), r)
    if best is not None:
        return True, best, best_score
    return False, None, 0.0

def detect_X_in_roi(gray_roi, c1, c2, min_len, ang_diff_deg):
    edges = cv2.Canny(gray_roi, c1, c2)
    linesP = cv2.HoughLinesP(edges, 1, np.pi/180, threshold=32,
                             minLineLength=min_len, maxLineGap=6)
    if linesP is None:
        return False, None, 0.0
    lines = [tuple(l[0]) for l in linesP]

    # two-line crossing with angle near 90¬∞
    best_pair = None; best_ang = 0; best_len = 0
    for i in range(len(lines)):
        for j in range(i+1, len(lines)):
            a1 = angle_of(lines[i]); a2 = angle_of(lines[j])
            diff = abs(a1 - a2); diff = min(diff, 180-diff)
            if diff >= ang_diff_deg:
                p = intersection((lines[i][0],lines[i][1]), (lines[i][2],lines[i][3]),
                                 (lines[j][0],lines[j][1]), (lines[j][2],lines[j][3]))
                if p is not None:
                    Lsum = line_len(lines[i]) + line_len(lines[j])
                    if diff > best_ang or (diff==best_ang and Lsum>best_len):
                        best_ang = diff; best_len = Lsum; best_pair = (p, lines[i], lines[j])
    if best_pair:
        (cx,cy),_,_ = best_pair
        ang_score = max(0.0, 1.0 - abs(90 - best_ang)/45.0)
        len_score = min(1.0, best_len/200.0)
        score = 0.6*ang_score + 0.4*len_score
        return True, (int(cx),int(cy)), float(score)

    # fallback: strong single diagonal slash
    best_single = None; best_L = 0
    for ln in lines:
        ang = angle_of(ln); L = line_len(ln)
        if ((35 <= ang <= 55) or (125 <= ang <= 145)) and L >= (min_len*1.4):
            if L > best_L: best_L = L; best_single = ln
    if best_single is not None:
        cx = int((best_single[0]+best_single[2])//2); cy = int((best_single[1]+best_single[3])//2)
        return True, (cx,cy), min(0.6, best_L/240.0)

    return False, None, 0.0

# ---------- Per-cell classification ----------
def classify_cell(gray_full, W, H, args, letter):
    x0,y0,x1,y1 = letter_cell_rect(letter, W, H)
    roi = gray_full[y0:y1, x0:x1]

    # quick "edge presence" floor to ignore empty cells
    e = cv2.Canny(roi, args.canny1, args.canny2)
    if np.count_nonzero(e) / float(e.size) < args.edge_floor:
        return None, 0.0, None  # (sym, score, drawinfo)

    # slight normalization helps pencil strokes
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(4,4))
    roi_eq = clahe.apply(roi)

    okO, o_cir, o_score = detect_O_in_roi(roi_eq, args.canny1, args.canny2, args.o_min_r, args.o_max_r)
    okX, x_pt,  x_score = detect_X_in_roi(roi_eq, args.canny1, args.canny2, args.x_min_len, args.x_ang_diff)

    # score thresholds
    if okO and (o_score < args.o_thresh): okO = False
    if okX and (x_score < args.x_thresh): okX = False

    # decision (respect --prefer)
    if okO and okX:
        if args.prefer == 'O':   return 'O', o_score, (x0+o_cir[0], y0+o_cir[1], o_cir[2])
        if args.prefer == 'X':   return 'X', x_score, (x0+x_pt[0], y0+x_pt[1])
        # prefer any: argmax
        if o_score >= x_score:   return 'O', o_score, (x0+o_cir[0], y0+o_cir[1], o_cir[2])
        else:                    return 'X', x_score, (x0+x_pt[0], y0+x_pt[1])
    if okO: return 'O', o_score, (x0+o_cir[0], y0+o_cir[1], o_cir[2])
    if okX: return 'X', x_score, (x0+x_pt[0], y0+x_pt[1])
    return None, 0.0, None

# ---------- ROS publisher ----------
class YoloTrigger(Node):
    def __init__(self):
        super().__init__('agent_xo_sleep')
        self.pub = self.create_publisher(String, '/yolo/trigger', 10)
    def send(self, s):
        self.pub.publish(String(data=s))

# ---------- Main ----------
def main():
    ap = argparse.ArgumentParser(description="Simple XO detector with verify window and A‚ÄìI cell labels.")
    ap.add_argument('--cam', choices=['usb','d435'], default='usb')
    ap.add_argument('--usb-dev', type=int, default=0)
    ap.add_argument('--res', default='640x480')
    ap.add_argument('--fps', type=int, default=30)

    # Vision params
    ap.add_argument('--canny1', type=int, default=70)
    ap.add_argument('--canny2', type=int, default=140)
    ap.add_argument('--x-min-len', type=int, default=16)
    ap.add_argument('--x-ang-diff', type=float, default=40.0)
    ap.add_argument('--o-min-r', type=int, default=10)
    ap.add_argument('--o-max-r', type=int, default=80)

    # Decision thresholds
    ap.add_argument('--o-thresh', type=float, default=0.60)
    ap.add_argument('--x-thresh', type=float, default=0.48)
    ap.add_argument('--edge-floor', type=float, default=0.018, help="min edge ratio to consider cell non-empty")

    # Verify + hold
    ap.add_argument('--verify-n', type=int, default=3, help='frames required to agree before holding')
    ap.add_argument('--hold', type=float, default=3.0, help='seconds to hold stable label before publish')

    # Behavior
    ap.add_argument('--prefer', choices=['any','X','O'], default='any')
    ap.add_argument('--ros', action='store_true')
    ap.add_argument('--show', action='store_true')
    args = ap.parse_args()

    # Open camera
    if args.cam == 'usb':
        read, close, src_name = open_usb_cam(device=args.usb_dev, res=args.res, fps=args.fps)
    else:
        read, close, src_name = open_d435(args.res, args.fps)

    print(f"‚úÖ Camera ready ({src_name}), hold={args.hold:.1f}s, prefer={args.prefer}")

    node = None
    if args.ros and USE_ROS:
        rclpy.init(args=None); node = YoloTrigger()

    # State
    occupied = set()  # letters already taken (A..I)
    verify_q = collections.deque(maxlen=args.verify_n)
    current = None
    start_t = None

    try:
        while True:
            frame = read()
            if frame is None: continue
            H, W = frame.shape[:2]
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            gray = cv2.GaussianBlur(gray, (5,5), 0)

            # evaluate each FREE cell, pick best candidate
            cand = None  # (score, label, sym, letter)
            for L in LETTERS:
                if L in occupied: 
                    continue
                sym, score, _ = classify_cell(gray, W, H, args, L)
                if sym:
                    label = f"{L}|{sym}"
                    if (cand is None) or (score > cand[0]):
                        cand = (score, label, sym, L)

            label = cand[1] if cand else None

            # verify before hold (like your YOLO script)
            if label:
                verify_q.append(label)
                stable = (len(verify_q)==verify_q.maxlen) and (len(set(verify_q))==1)
                if stable:
                    if current != label:
                        current = label
                        start_t = time.time()
                    else:
                        if time.time() - start_t >= args.hold:
                            print(f"[AGENT] -> /yolo/trigger: {label}")
                            if node: node.send(label)
                            occupied.add(label.split('|')[0])  # mark cell taken
                            verify_q.clear(); current=None; start_t=None
                            time.sleep(0.30)
            else:
                verify_q.clear(); current=None; start_t=None

            if args.show:
                draw_grid_and_labels(frame, occupied)
                if label:
                    Ltr = label.split('|')[0]
                    x0,y0,x1,y1 = letter_cell_rect(Ltr, W, H)
                    cv2.rectangle(frame, (x0+3,y0+3),(x1-3,y1-3),(0,255,0),2)
                    if current == label and start_t is not None:
                        held = time.time() - start_t
                        cv2.putText(frame, f"HOLD {held:.1f}/{args.hold:.1f}s {label}",
                                    (10,30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0,255,0), 2)
                    else:
                        cv2.putText(frame, f"CAND {label}", (10,30),
                                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0,255,255), 2)
                cv2.imshow(f"XO detector ({src_name})", frame)
                if (cv2.waitKey(1) & 0xFF) == ord('q'):
                    break

    finally:
        close()
        if args.show: cv2.destroyAllWindows()
        if node:
            try: node.destroy_node(); rclpy.shutdown()
            except Exception: pass

if __name__ == "__main__":
    main()   





####  grid 


from __future__ import annotations
import json, os, time, glob, shutil
from pathlib import Path
from typing import Dict

# --- Poses used everywhere ---
SCAN_POSE = {"x": 260.0, "y": 40.0, "z": 250.0, "r": 0.0}
Z_TRAVEL  = 75.0
Z_DRAW    = 2.0       # pen touching paper
DWELL_S   = 0.15      # small settle at pen down/up

DEFAULT_CELLS12 = {
    "H1_left":  {"x": 258.7, "y": -16.8},
    "H1_right": {"x": 345.7, "y": -14.2},
    "H2_left":  {"x": 259.4, "y":  31.1},
    "H2_right": {"x": 344.0, "y":  31.0},
    "V1_top":   {"x": 287.8, "y": -62.9},
    "V1_bot":   {"x": 287.5, "y":  78.1},
    "V2_top":   {"x": 317.6, "y": -61.2},
    "V2_bot":   {"x": 314.9, "y":  77.2},
}

LETTERS = "ABCDEFGHI"

def build_cell_centers(c: Dict[str, Dict[str, float]]) -> Dict[str, Dict[str, float]]:
    xs = sorted([c["H1_left"]["x"], c["V1_top"]["x"], c["V2_top"]["x"], c["H1_right"]["x"]])
    ys = sorted([c["V1_top"]["y"], c["H1_left"]["y"], c["H2_left"]["y"], c["V1_bot"]["y"]])
    def mid(a,b): return (a+b)/2.0
    cols = [ mid(xs[0], xs[1]), mid(xs[1], xs[2]), mid(xs[2], xs[3]) ]
    rows = [ mid(ys[0], ys[1]), mid(ys[1], ys[2]), mid(ys[2], ys[3]) ]
    centers = {}
    k = 0
    for r in range(3):
        for cidx in range(3):
            centers[LETTERS[k]] = {"x": cols[cidx], "y": rows[r]}
            k += 1
    centers["HOME"] = {"x": SCAN_POSE["x"], "y": SCAN_POSE["y"]}
    return centers

def load_cells12() -> Dict[str, Dict[str,float]]:
    p = Path("cells12.json")
    if p.exists():
        try:
            return json.loads(p.read_text())
        except Exception:
            pass
    base = dict(DEFAULT_CELLS12)
    y2 = round((base["H2_left"]["y"] + base["H2_right"]["y"]) / 2.0, 3)
    base["H2_left"]["y"]  = y2
    base["H2_right"]["y"] = y2
    return base

def ensure_cells12():
    c12 = load_cells12()
    centers = build_cell_centers(c12)
    return {"cells12": c12, "centers": centers}

def _ensure_dir_for(path: str):
    d = os.path.dirname(path)
    if d:
        os.makedirs(d, exist_ok=True)

def _fallback_from_agent_snapshots(target_path: str) -> bool:
    """When camera is busy, copy the most recent image from snapshots/."""
    try:
        cand = sorted(glob.glob("snapshots/*.png"), key=os.path.getmtime, reverse=True)
        if not cand:
            return False
        _ensure_dir_for(target_path)
        shutil.copy2(cand[0], target_path)
        print(f"[SNAP] camera busy ‚Üí copied latest agent snapshot ‚Üí {target_path}")
        return True
    except Exception as e:
        print(f"[SNAP] fallback failed: {e}")
        return False

def run_grid_snapshot(usb_dev=0, out_path="snapshots/grid.png"):
    """
    Try to capture from camera. If the camera is busy (opened by agent_xo_sleep.py),
    fall back to copying the most recent image from snapshots/ so Task files still
    write a PNG into the requested location.
    """
    try:
        import cv2
        _ensure_dir_for(out_path)
        cap = cv2.VideoCapture(int(usb_dev))
        # If camera fails to open, fallback
        if (not cap.isOpened()) or (not cap.read()[0]):
            cap.release()
            if _fallback_from_agent_snapshots(out_path):
                return out_path
            print(f"[SNAP] camera {usb_dev} not available and no fallback.")
            return None

        # Warm-up & capture
        for _ in range(4):
            cap.read()
        ok, frame = cap.read()
        cap.release()
        if ok:
            ts = int(time.time())
            base, ext = os.path.splitext(out_path)
            out = f"{base}_{ts}{ext}"
            cv2.imwrite(out, frame)
            print(f"[SNAP] saved ‚Üí {out}")
            return out
        # If read failed, fallback
        if _fallback_from_agent_snapshots(out_path):
            return out_path
    except Exception as e:
        print(f"[SNAP] error: {e}")
        if _fallback_from_agent_snapshots(out_path):
            return out_path
    return None

def to_scan_wait(drawer, hold_s: float|int = 0):
    if drawer is None: return
    try:
        drawer.move_to(SCAN_POSE["x"], SCAN_POSE["y"], SCAN_POSE["z"], SCAN_POSE["r"], wait=False)
    except Exception as e:
        print(f"[SCAN] move error: {e}")
    if hold_s and hold_s > 0:
        time.sleep(float(hold_s))

def _pen_down(drawer, x, y):
    drawer.move_to(x, y, Z_DRAW, 0.0, wait=True)
    try: drawer.pen_down()
    except Exception: pass
    time.sleep(DWELL_S)

def _pen_up(drawer):
    try: drawer.pen_up()
    except Exception: pass
    time.sleep(DWELL_S)

def _seg_line(drawer, x1,y1, x2,y2):
    drawer.move_to(x1, y1, Z_TRAVEL, 0.0, wait=False)
    _pen_down(drawer, x1, y1)
    drawer.move_to(x2, y2, Z_DRAW, 0.0, wait=True)
    _pen_up(drawer)
    drawer.move_to(x2, y2, Z_TRAVEL, 0.0, wait=False)

def draw_grid_if_yes(drawer, cells12=None, hold_s=0, usb_dev=None):
    ans = input("Make grid? [y/N]: ").strip().lower()
    if ans not in ("y", "yes"):
        print("[WARN] Grid draw skipped.")
        return ensure_cells12()["centers"]

    c = load_cells12() if cells12 is None else cells12
    print("[GRID] Drawing H1‚Ä¶")
    _seg_line(drawer, c["H1_left"]["x"], c["H1_left"]["y"], c["H1_right"]["x"], c["H1_right"]["y"])
    print("[GRID] Drawing H2‚Ä¶")
    _seg_line(drawer, c["H2_left"]["x"], c["H2_left"]["y"], c["H2_right"]["x"], c["H2_right"]["y"])
    print("[GRID] Drawing V1‚Ä¶")
    _seg_line(drawer, c["V1_top"]["x"],  c["V1_top"]["y"],  c["V1_bot"]["x"],  c["V1_bot"]["y"])
    print("[GRID] Drawing V2‚Ä¶")
    _seg_line(drawer, c["V2_top"]["x"],  c["V2_top"]["y"],  c["V2_bot"]["x"],  c["V2_bot"]["y"])

    print("[GRID] Done.")
    if usb_dev is not None:
        run_grid_snapshot(usb_dev, "snapshots/grid.png")
    to_scan_wait(drawer, hold_s or 0)
    return ensure_cells12()["centers"]    





#### task1  


#!/usr/bin/env python3
import argparse, rclpy
from rclpy.node import Node
from std_msgs.msg import String
from robot_draw import RobotDraw
from common_game import winner, best_move, letter_to_rc, apply_move, new_board
from board_print import print_matrix, rc_to_letter
from grid_utils import draw_grid_if_yes, to_scan_wait, run_grid_snapshot

class Task1(Node):
    """Task 1: Human vs Robot (snapshots saved in snapshots/)."""
    def __init__(self, port, hold_s=3.0, usb_dev=0):
        super().__init__('task1_usb')
        self.sub = self.create_subscription(String, '/yolo/trigger', self.on_trigger, 10)
        self.drawer = RobotDraw(port=port)
        self.M = new_board()
        self.hold = hold_s
        self.usb_dev = usb_dev

        draw_grid_if_yes(self.drawer, hold_s=self.hold, usb_dev=self.usb_dev)

        while True:
            sym = input("Select your symbol (human): [X/O]: ").strip().upper()
            if sym in ('X', 'O'):
                break
        self.human = sym
        self.robot = 'O' if sym == 'X' else 'X'
        self.turn = 'H'
        print(f"[INFO] Human={self.human}, Robot={self.robot}")
        print_matrix(self.M)
        print("[INFO] Waiting for detector...")

    def _snap(self, tag):
        # Always write under snapshots/
        out = run_grid_snapshot(self.usb_dev, f"snapshots/{tag}.png")
        if out:
            print(f"[VERIFY] Saved ‚Üí {out}")
        else:
            print("[VERIFY] Snapshot failed")

    def robot_move(self):
        mv = best_move(self.M, my=self.robot, opp=self.human)
        if not mv:
            print("[INFO] No robot move (tie/full).")
            return
        r, c = mv
        apply_move(self.M, r, c, self.robot)
        try:
            self.drawer.draw_symbol_rc(self.robot, r, c)
        except Exception:
            pass
        to_scan_wait(self.drawer, self.hold)
        print(f"[ROBOT] {self.robot} at {rc_to_letter(r,c)}")
        print_matrix(self.M)
        self._snap(f"task1_robot_{rc_to_letter(r,c)}")
        w = winner(self.M)
        if w:
            print("üéâ Winner:", w)

    def on_trigger(self, msg: String):
        data = (msg.data or "").strip()
        if '|' not in data:
            return
        loc, raw = data.split('|', 1)
        s = raw.strip().upper()
        rc = letter_to_rc(loc.strip().upper())
        if not rc:
            return
        r, c = rc

        if s != self.human:
            return
        if self.M[r][c] != ' ':
            print("[WARN] Cell already taken.")
            return

        apply_move(self.M, r, c, self.human)
        print(f"[HUMAN] {self.human} at {rc_to_letter(r,c)}")
        print_matrix(self.M)
        self._snap(f"task1_human_{rc_to_letter(r,c)}")

        w = winner(self.M)
        if w:
            print("üéâ Winner:", w)
            return

        to_scan_wait(self.drawer, self.hold)
        self.robot_move()

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--port', default=None)
    ap.add_argument('--hold', type=float, default=3.0)
    ap.add_argument('--usb-dev', type=int, default=0)
    args = ap.parse_args()

    rclpy.init()
    node = Task1(args.port, hold_s=args.hold, usb_dev=args.usb_dev)
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        try: node.destroy_node()
        except: pass
        try: rclpy.shutdown()
        except: pass

if __name__ == '__main__':
    main()    




#### task 2  



#!/usr/bin/env python3
import argparse, rclpy, time
from rclpy.node import Node
from std_msgs.msg import String

from robot_draw import RobotDraw
from common_game import winner, best_move, letter_to_rc, apply_move, new_board
from board_print import print_matrix, rc_to_letter

from grid_utils import prompt_make_grid_and_ready, to_scan_wait

class Task2(Node):
    """Pick who starts (H/R); then play. Grid prompt & scan/ready included."""
    def __init__(self, port, delay_s=3.0):
        super().__init__('task2_pick_start')
        self.sub = self.create_subscription(String, '/yolo/trigger', self.on_trigger, 10)

        self.drawer = RobotDraw(port=port)
        self.M = new_board()
        self.hold = delay_s
        self.human = 'O'  # default pair (human asks by detector), robot is 'X'
        self.robot = 'X'

        prompt_make_grid_and_ready(self.drawer, self.hold)

        while True:
            st = input("Who starts first? (H for Human, R for Robot): ").strip().upper()
            if st in ('H','R'):
                self.turn = st
                break
            print("Enter H or R.")

        print("[INFO] Task2: starter =", self.turn, " Human=O Robot=X")
        print_matrix(self.M)

        if self.turn == 'R':
            print(f"[INFO] holding {self.hold:.1f}s at scan before robot draw‚Ä¶")
            to_scan_wait(self.drawer, self.hold)
            self.robot_move()

    def robot_move(self):
        mv = best_move(self.M, my=self.robot, opp=self.human)
        if not mv:
            print("[INFO] No robot move available (tie/full).")
            return
        r,c = mv
        apply_move(self.M, r, c, self.robot)
        try:
            self.drawer.draw_symbol_rc(self.robot, r, c)
        except Exception:
            pass
        to_scan_wait(self.drawer, self.hold)
        print(f"[ROBOT] {self.robot} at {rc_to_letter(r,c)}")
        print_matrix(self.M)
        w = winner(self.M)
        if w:
            if w == self.robot:
                print("üòÇ Hahaha, I win! You‚Äôre a tough opponent‚Äîbut I‚Äôm the tic-tac-toe king!")
            elif w == self.human:
                print("üëè Nice! You win.")
            else:
                print("ü§ù Tie.")
            return
        self.turn = 'H'

    def on_trigger(self, msg: String):
        if self.turn != 'H': return
        data = (msg.data or "").strip()
        if '|' not in data: return
        loc, raw = data.split('|',1)
        sym = raw.strip().upper()
        if sym != self.human:
            print(f"[WARN] Unexpected symbol {sym} ignored (expecting {self.human})")
            return

        if ',' in loc:
            try: r,c = [int(x) for x in loc.split(',',1)]
            except: return
        else:
            rc = letter_to_rc(loc.strip().upper())
            if not rc: return
            r,c = rc

        if not (0<=r<3 and 0<=c<3): return
        if self.M[r][c] != ' ':
            print("[WARN] Cell occupied.")
            return

        apply_move(self.M, r, c, self.human)
        print(f"[HUMAN] {self.human} at {rc_to_letter(r,c)}")
        print_matrix(self.M)
        w = winner(self.M)
        if w:
            if w == self.robot:
                print("üòÇ Hahaha, I win! You‚Äôre a tough opponent‚Äîbut I‚Äôm the tic-tac-toe king!")
            elif w == self.human:
                print("üëè Nice! You win.")
            else:
                print("ü§ù Tie.")
            return

        self.turn = 'R'
        print(f"[INFO] holding {self.hold:.1f}s at scan before robot draw‚Ä¶")
        to_scan_wait(self.drawer, self.hold)
        self.robot_move()

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--port', default=None)
    ap.add_argument('--delay', type=float, default=3.0)
    args = ap.parse_args()

    rclpy.init()
    node = Task2(args.port, delay_s=args.delay)
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        try: node.destroy_node()
        except: pass
        try: rclpy.shutdown()
        except: pass

if __name__=='__main__': main()  




##### task3

a

#!/usr/bin/env python3
import argparse, rclpy, time
from rclpy.node import Node
from std_msgs.msg import String

from robot_draw import RobotDraw
from common_game import winner, best_move, letter_to_rc, apply_move, new_board
from board_print import print_matrix, rc_to_letter
from grid_utils import prompt_make_grid_and_ready, to_scan_wait

# Accept these as "X" from vision
_X_KEYS = {'X','x','L','l','/','\\'}

class Task3A(Node):
    """
    COMPLETE GAME:
      - Human places TWO X first; then normal alternation: human(X), robot(O), ...
      - After every drawn symbol, go to SCAN and hold.
      - Stop on win/tie.
    """
    def __init__(self, port, hold_s=3.0, debounce_s=0.8):
        super().__init__('task3a_two_x_first')
        self.sub = self.create_subscription(String, '/yolo/trigger', self.on_trigger, 10)

        self.drawer = RobotDraw(port=port)   # SIM if port fails (your RobotDraw already handles this)
        self.M = new_board()
        self.hold = hold_s
        self.robot ='O'
        self.human ='X'

        # phase control
        self.need_two = 2              # human must place 2 X first
        self.game_over = False
        self.awaiting_human = True     # after the 2 initial X's, we alternate with human first
        self.last_hit_t = 0.0
        self.debounce_s = debounce_s

        prompt_make_grid_and_ready(self.drawer, self.hold)
        print("[INFO] Task 3A: Human places two X first; Robot plays O, then alternate turns.")
        print_matrix(self.M)

    # ---------- helpers ----------
    def _apply_and_print(self, r, c, who):
        apply_move(self.M, r, c, who)
        label = rc_to_letter(r, c)
        side = "HUMAN" if who == self.human else "ROBOT"
        sym  = "X" if who == self.human else "O"
        print(f"[{side}] {sym} at {label}")
        print_matrix(self.M)

    def _check_end(self):
        w = winner(self.M)
        if w:
            if w == self.robot:
                print("üéâ O (robot) wins!")
            elif w == self.human:
                print("üëè X (human) wins!")
            else:
                print("ü§ù Tie.")
            self.game_over = True
            return True
        # tie if no move left for either side
        if best_move(self.M, my='X', opp='O') is None and best_move(self.M, my='O', opp='X') is None:
            print("ü§ù Tie.")
            self.game_over = True
            return True
        return False

    def _robot_turn(self):
        if self.game_over: return
        mv = best_move(self.M, my=self.robot, opp=self.human)
        if mv is None:
            print("ü§ù Tie.")
            self.game_over = True
            return

        r, c = mv
        # draw physically (or SIM) then scan-hold
        try:
            self.drawer.draw_symbol_rc('O', r, c)
        except Exception:
            # still update board if physical draw fails in SIM
            pass
        to_scan_wait(self.drawer, self.hold)
        self._apply_and_print(r, c, self.robot)
        if self._check_end(): return
        self.awaiting_human = True

    # ---------- main callback ----------
    def on_trigger(self, msg: String):
        if self.game_over:
            return
        # debounce
        now = time.time()
        if (now - self.last_hit_t) < self.debounce_s:
            return
        self.last_hit_t = now

        data = (msg.data or "").strip()
        if '|' not in data:
            return
        loc, raw = data.split('|', 1)
        raw = raw.strip()

        # We only accept HUMAN 'X' placements from vision
        if raw not in _X_KEYS:
            return

        # parse location
        if ',' in loc:
            try:
                r, c = [int(x) for x in loc.split(',', 1)]
            except Exception:
                return
        else:
            rc = letter_to_rc(loc.strip().upper())
            if not rc:
                return
            r, c = rc

        # bounds and occupancy
        if not (0 <= r < 3 and 0 <= c < 3):
            return
        if self.M[r][c] != ' ':
            print("[WARN] Cell occupied; ignoring.")
            return

        # ----- Initial phase: collect 2 X -----
        if self.need_two > 0:
            self._apply_and_print(r, c, self.human)
            if self._check_end(): return
            self.need_two -= 1

            if self.need_two == 0:
                # Robot answers once, then alternate
                print(f"[INFO] holding {self.hold:.1f}s at scan before robot draw‚Ä¶")
                to_scan_wait(self.drawer, self.hold)
                self.awaiting_human = False
                self._robot_turn()
            else:
                # still need one more X before robot draws
                return
            return

        # ----- Normal alternation after initial two X -----
        if not self.awaiting_human:
            # Not the human's turn yet ‚Äî ignore stray triggers that arrive while robot is acting
            return

        # Apply human move
        self._apply_and_print(r, c, self.human)
        if self._check_end(): return

        # Move to scan & hold, then robot turn
        print(f"[INFO] holding {self.hold:.1f}s at scan before robot draw‚Ä¶")
        to_scan_wait(self.drawer, self.hold)
        self.awaiting_human = False
        self._robot_turn()

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--port', default=None, help='USB port like /dev/ttyACM0')
    ap.add_argument('--hold', type=float, default=3.0, help='Seconds to hold at SCAN')
    ap.add_argument('--debounce', type=float, default=0.8, help='Debounce seconds for /yolo/trigger')
    args = ap.parse_args()

    rclpy.init()
    node = Task3A(args.port, hold_s=args.hold, debounce_s=args.debounce)
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        try: node.destroy_node()
        except: pass
        try: rclpy.shutdown()
        except: pass

if __name__=='__main__':
    main()




b

#!/usr/bin/env python3
import argparse, time, rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy
from std_msgs.msg import String

from robot_draw import RobotDraw
from common_game import new_board, apply_move, winner, best_move
from board_print import print_matrix, rc_to_letter
from grid_utils import prompt_make_grid_and_ready, to_scan_wait
from detect_utils import parse_rc_sym

class Task3B(Node):
    """
    Normal game (Human vs Robot) but Human is X-only.
    If detector sends '...|O' => print ERROR and ignore.
    Robot plays 'O'. Detector messages are 'r,c|S' (e.g., 1,2|X).
    """
    def __init__(self, port, hold_s=3.0, topic='/yolo/trigger', timeout_s=8.0, starter='H'):
        super().__init__('task3b_error_o')
        qos = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE,
            history=HistoryPolicy.KEEP_LAST,
            depth=10
        )
        self.sub = self.create_subscription(String, topic, self.on_trigger, qos)
        print(f"[SUB] listening on {topic} (std_msgs/String)")

        self.drawer = RobotDraw(port=port)
        self.M = new_board()
        self.hold = hold_s
        self.timeout_s = timeout_s
        self.turn = starter.upper()  # 'H' or 'R'
        self.last_wait_t0 = None

        self.human = 'X'
        self.robot = 'O'

        prompt_make_grid_and_ready(self.drawer, self.hold)
        print(f"[INFO] Task 3B: Human=X (O is illegal), Robot=O, Starter={self.turn}")
        print_matrix(self.M)

        if self.turn == 'R':
            print(f"[INFO] Robot starts after {self.hold:.1f}s at scan‚Ä¶")
            to_scan_wait(self.drawer, self.hold)
            self.robot_move()
        else:
            print("[INFO] Waiting for detector (r,c|X). O is error and ignored.")
            self.last_wait_t0 = time.monotonic()
            self.timer = self.create_timer(0.25, self._watchdog_tick)

    def _watchdog_tick(self):
        if self.turn != 'H' or self.last_wait_t0 is None:
            return
        if (time.monotonic() - self.last_wait_t0) >= self.timeout_s:
            print(f"[TIMEOUT] No human detection in {self.timeout_s:.1f}s ‚Üí robot moves.")
            self.turn = 'R'
            to_scan_wait(self.drawer, self.hold)
            self.robot_move()
            self.last_wait_t0 = None

    def end_check(self):
        w = winner(self.M)
        if w:
            if w == self.robot:
                print("üòÇ Hahaha, I win! You‚Äôre a tough opponent‚Äîbut I‚Äôm the tic-tac-toe king!")
            elif w == self.human:
                print("üëè Nice! You win.")
            else:
                print("ü§ù Tie.")
            return True
        if all(self.M[r][c] != ' ' for r in range(3) for c in range(3)):
            print("ü§ù Tie.")
            return True
        return False

    def robot_move(self):
        mv = best_move(self.M, my=self.robot, opp=self.human)
        if not mv:
            print("ü§ù Tie / no move.")
            return
        r,c = mv
        apply_move(self.M, r, c, self.robot)
        try:
            self.drawer.draw_symbol_rc(self.robot, r, c)
        except Exception:
            pass
        to_scan_wait(self.drawer, self.hold)

        print(f"[ROBOT] {self.robot} at {rc_to_letter(r,c)}")
        print_matrix(self.M)
        if self.end_check():
            return
        self.turn = 'H'
        self.last_wait_t0 = time.monotonic()
        print("[INFO] Your turn (detector r,c|X). O is illegal.")

    def on_trigger(self, msg: String):
        raw = (msg.data or "").strip()
        print(f"[RX] {raw}")
        if self.turn != 'H':
            return

        r,c,s = parse_rc_sym(raw)
        if r is None:
            return
        if s == 'O':
            print("[ERROR] Illegal move: 'O' detected. Ignored.")
            return
        if s != 'X':
            print(f"[WARN] Unexpected symbol {s} (expect X). Ignored.")
            return
        if self.M[r][c] != ' ':
            print("[WARN] Cell occupied.")
            return

        apply_move(self.M, r, c, 'X')
        print(f"[HUMAN] X at {rc_to_letter(r,c)}")
        print_matrix(self.M)
        if self.end_check():
            return

        self.turn = 'R'
        self.last_wait_t0 = None
        to_scan_wait(self.drawer, self.hold)
        self.robot_move()

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--port', default=None)
    ap.add_argument('--hold', type=float, default=3.0)
    ap.add_argument('--topic', default='/yolo/trigger')
    ap.add_argument('--timeout', type=float, default=8.0)
    ap.add_argument('--starter', choices=['H','R'], default='H')
    args = ap.parse_args()

    rclpy.init()
    node = Task3B(args.port, hold_s=args.hold, topic=args.topic, timeout_s=args.timeout, starter=args.starter)
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        try: node.destroy_node()
        except: pass
        try: rclpy.shutdown()
        except: pass

if __name__=='__main__': main()   




#### task4



from grid_utils import load_cells12, scan_pose, Z_DRAW, Z_TRAVEL
from common_game import safe_parse_payload, apply_move, winner, best_move, rc_to_letter
#!/usr/bin/env python3
import time
from board_print import print_matrix
from common_game import *
from common_agent import best_move
from robot_draw import RobotDraw

def draw_safe(d,sym,cell):
    try: d.draw_symbol(cell,sym)
    except Exception as e: print("[WARN] draw:",e)

def main():
    # pick our mark
    my = None
    while my not in ('X','O'):
        my = input("Our symbol? (X/O): ").strip().upper()
    opp = 'O' if my=='X' else 'X'
    # who starts
    starter=None
    while starter not in ('H','R'):
        starter=input("Who starts? (H = Opponent/Other Robot, R = Us): ").strip().upper()

    drawer=RobotDraw(port=None)
    try: drawer.draw_grid()
    except Exception as e: print("[WARN] grid:",e)

    board=new_board()
    print(f"[INFO] Task4 ‚Äî vs other robot. We={my}, Opp={opp}, starter={'Opp' if starter=='H' else 'Us'}")
    print_matrix(board)
    sub=HumanMoveSub('/yolo/trigger')

    # if we start
    if starter=='R':
        m=best_move(board, me=my, them=opp)
        if m:
            r,c=m; cell=rc_to_letter(r,c)
            board[r][c]=my
            print(f"[US] {my} at {cell}")
            draw_safe(drawer,my,cell)
            print_matrix(board)

    turn='H' if starter=='R' else 'R'
    try:
        while True:
            if turn=='H':
                # expect opponent to place their symbol (opp) detected by camera
                while True:
                    L,lab=sub.next(timeout=None)
                    if not L: continue
                    if lab and lab != opp:
                        print(f"[INFO] ignoring {lab} at {L}; expecting {opp} from opponent.")
                        continue
                    r,c=letter_to_rc(L)
                    if board[r][c] != ' ':
                        print("[INFO] occupied; waiting opponent proper move‚Ä¶"); continue
                    board[r][c]=opp
                    print(f"[OPP] {opp} at {L}")
                    # we don't draw opponent symbol with our robot
                    print_matrix(board)
                    break
                if check_winner(board) or full(board): break
                time.sleep(5.0)
                turn='R'
            else:
                m=best_move(board, me=my, them=opp)
                if not m: print("ü§ù Draw."); break
                r,c=m; cell=rc_to_letter(r,c)
                board[r][c]=my
                print(f"[US] {my} at {cell}")
                draw_safe(drawer,my,cell)
                print_matrix(board)
                if check_winner(board) or full(board): break
                turn='H'
        w=check_winner(board)
        if w==my: print("‚úÖ We win!")
        elif w==opp: print("‚úÖ Opponent wins!")
        else: print("ü§ù Draw.")
    finally:
        try: sub.close()
        except: pass
        try: drawer.close()
        except: pass

if __name__=='__main__':
    main()


def on_trigger(msg):
    raw=getattr(msg,'data',str(msg))
    print(f'[RX] /yolo/trigger: {raw}')
    parsed=safe_parse_payload(raw)
    if not parsed:
        print('[RX] ignore (cannot parse)');return
    r,c,sym=parsed
    if not sym:sym='X'
    handle_move(r,c,sym)







